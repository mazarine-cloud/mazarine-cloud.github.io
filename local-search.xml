<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/05/hello-world/"/>
    <url>/2020/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unix/linux</title>
    <link href="/2020/05/20/Unix_Linux/"/>
    <url>/2020/05/20/Unix_Linux/</url>
    
    <content type="html"><![CDATA[<p>echo 指令</p><p>echo 输出内容到控制台。<br>•基本语法<br>echo    [选项]    [输出内容]<br>•应用实例<br>案例: 使用 echo 指令输出环境变量,输出当前的环境路径。<br>案例: 使用 echo 指令输出 hello,world!</p><p>head 指令</p><p>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容<br>•基本语法<br>head  文件    (功能描述：查看文件头 10 行内容)<br>head -n 5 文件    (功能描述：查看文件头 5 行内容，5 可以是任意行数)<br>•应用实例<br>案例: 查看/etc/profile 的前面 5 行代码</p><p>tail 指令</p><p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。<br>•基本语法<br>1)tail    文件    （功能描述：查看文件后 10 行内容）<br>2)tail    -n 5 文件    （功能描述：查看文件后 5 行内容，5 可以是任意行数）<br>3)tail    -f    文件    （功能描述：实时追踪该文档的所有更新，工作经常使用）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unix/Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Orcle数据库</title>
    <link href="/2020/05/15/Oracle_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0_%E5%88%86%E9%A1%B5/"/>
    <url>/2020/05/15/Oracle_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0_%E5%88%86%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h2><p> &emsp;<b>   Round()、TRUNC()、</b></p><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><p>&emsp;&emsp;单行函数：作用于一行，返回一个值</p><h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><pre><code>select upper（&apos;yes&apos;）from 表名;--小写转大写select lower（&apos;Yes&apos;）from 表名;--大写转小写</code></pre><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><pre><code>Round()函数: 传回一个数值，该数值是按照指定的小数位元数进行四舍五入运算的结果        语法:        ROUND( number, decimal_places )                     number : 需四舍五入处理的数值         decimal_places : 四舍五入 , 小数取几位 ( 预设为 0 )        返回值类型 数字    例子:        select round(123.456, 0) from dual; 回传 123         select round(123.456, 1) from dual; 回传 123.5         select round(123.456, 2) from dual; 回传 123.46         select round(123.456, 3) from dual; 回传 123.456         select round(-123.456, 2) from dual; 回传 -123.46</code></pre><p>TRUNC()函数: 截取数值</p><pre><code>语法：trunc(number,decimals)     number:指需要截取的数字.例子:         select  trunc(122.555) from  dual t; --默认取整     select  trunc(122.555,2) from  dual t;     select  trunc(122.555,-2) from  dual t;--负数表示从小数点左边开始截取2位</code></pre><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><pre><code>sysdate获取系统当前时间    --查询出emp表中所有员工入职距离现在多少天        select    sysdate-e.hiredate from emp e;    --算出明天此刻        select sysdate+1 from dual    --查询出emp表中所有员工入职距离在几月        select months between(sysdate,e.hiredate) fromemp e;    --查询出emp表中所有员工入职距离现在几年        select months between(sysdate,e.hiredate)/12 fromemp e;    --查询出emp表中所有员工入职距离现在几周        select months between(sysdate,e.hiredate)/7 fromemp e;</code></pre><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><pre><code>to_char     --日期转字符串     select to_char(systade,&apos;fm yyyy-mm-dd hh24:mi:ss&apos;) from  dual     --字符串转日期     select to_char(&apos;2020-1-1 13:09:34&apos;,&apos;fm yyyy-mm-dd hh24:mi:ss&apos;) from  dual</code></pre><h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><pre><code>语法    NVL(eExpression1, eExpression2)    参数    eExpression1, eExpression2    如果 eExpression1 的计算结果为 null 值，则 NVL( ) 返回 eExpression2。如果 eExpression1     的计算结果不是 null 值，则返回 eExpression1。eExpression1 和 eExpression2 可以是任意一种    数据类型。如果 eExpression1 与 eExpression2 的结果皆为 null 值，则 NVL( ) 返回 .NULL.。案例            --算出emp表中所有员工的年薪(值得注意有些员工没有奖金值为null，null和任何数字运算都是null)     select e.sal*12+nvl(e.comm,0)from emp e;</code></pre><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p> CASE WHEN语句(from_CSDN)</p><pre><code>面试题:    一张表数据如下     1900-1-1 胜     1900-1-1 胜     1900-1-1 负     1900-1-2 胜     1900-1-2 胜     写出一条SQL语句，使检索结果如下:      胜  负     1900-1-1 2   1     1900-1-2 2   0 </code></pre><p> 随手建了这样一个表：</p><pre><code>create table test(Date varchar(50) null, Result varchar(50) null);</code></pre><p>并将上面的数据都插入到表中。</p><p>经过一番尝试和修改，终于得到了答案：</p><pre><code>select distinct Date,sum(case Result when &apos;胜&apos; then 1 else 0 end) as &apos;胜&apos;,sum(case Result when &apos;负&apos; then 1 else 0 end) as &apos;负&apos;from testgroup by date</code></pre><P><span>其实是SQL中case when的用法。它在普通的SQL语句中似乎并不常见，我本人以前也没在实际项目中使用过。遇到类似问题，往往通过代码或多条SQL语句实现。或者是如下这种丑陋的SQL，并且还伴随着很多潜在的BUG（如,当没有'负'时）。</span><P><pre><code>select a.date,a.a1 胜,b.b1 负 from (select date,count(date) a1 from test where Result =&apos;胜&apos; group by date) a, (select date,count(date) b1 from test where Result =&apos;负&apos; group by date) b where a.date=b.date</code></pre><p>我们不妨来复习一下CASE WHEN的语法。</p><pre><code>CASE WHEN有两种用法，一种是类似上面例子中那样的简单CASE函数：CASE result    WHEN &apos;胜&apos; THEN 1    WHEN &apos;负&apos; THEN 2ELSE 0END</code></pre><p>还有一种是CASE搜索函数：</p><pre><code>CASE WHEN result=&apos;胜&apos; THEN 1     WHEN result=&apos;负&apos; THEN 2ELSE 0END</code></pre><p>其中result=’胜’可以替换为其他条件表达式。如果有多个CASE WHEN表达式符合条件，将只返回第一个符合条件的子句，其余子句将被忽略。</p><p>用CASE WHEN语句可以简化我们平时工作中遇到的很多问题。如性别在表中存的是数字1、2，但是希望查询出来男、女时，可以这样：</p><pre><code>select (case Gender when 1 then &apos;男&apos; when 2 then &apos;女&apos; else &apos;其他&apos;end) as Gender from Table1</code></pre><h3 id="多行函数-聚合函数"><a href="#多行函数-聚合函数" class="headerlink" title="多行函数 聚合函数"></a>多行函数 聚合函数</h3><p>   作用于多行，返回一个值(太简单了，略..<a href='https://blog.csdn.net/qq_40456829/article/details/83657396' target="_blank" rel="noopener">转载</a>)<br>1、求个数/记录数/项目数等：count()</p><p>例如: 统计员工个数?</p><pre><code>select count( ) from Company --包括空值select count(*) from Company --不包括空值</code></pre><p>2、求某一列平均数 :avg()<br>   例如：求某个班平均成绩 ？求某个公司员工的平均工资？</p><pre><code>select avg(score) from Scores ---平均成绩select avg(salary) from Company --平均工资</code></pre><p>  注意：<br>  若某行的score值为null时，计算平均值时会忽略带有null值得那一行。</p><p>如果想要把null当做0，那么可以使用IsNull函数把null转换成0，语法如下：</p><pre><code>avg(IsNull(score，0)） as ’Average Score‘</code></pre><p>3、求总和，总分等：sum() –必须为数字列</p><p>例如：求某个班的总成绩？求公司总薪资支出？</p><pre><code>select sum(score) from Scoresselect sum(salary) from Company</code></pre><p>4、求最大值，最高分，最高工资等：max()</p><p>例如：求班里最高分，公司员工最高工资？</p><pre><code>select max(Score) from Scoresselect max(salary) from Company</code></pre><p>5、求最小值，最低分，最低工资等：max()</p><p>例如：求班里最低分，公司员工最低工资？</p><pre><code>select min(Score) from Scoresselect min(salary) from Company</code></pre><h3 id="Oracle中的分页–rownum"><a href="#Oracle中的分页–rownum" class="headerlink" title="Oracle中的分页–rownum"></a>Oracle中的分页–rownum</h3><p>   –rownum行号：当我们做select操作的时候,<br><br>   –每查询出一行记录，就在该行加上一个行号。<br><br>   –行号从1开始，一次递增，不能跳着走。<br><br>   –emp表工资倒叙排列后没页五条数据，查询第二张表<br><br>   –排序操作hi影响rownum的顺序</p><pre><code>select rownum,e.* from emp e order by e.sal desc;</code></pre><p>   –如果涉及到排序，但是还要使用rownum的话，我们可以再次嵌套查询</p><pre><code>select rownum,t.* from(select rownum,e.* from emp e order by e.sal desc) t;--emp表工资倒序后，每页五条数据，查询第二页--rownum行号不能写上大于一个正数select*from（    select rownum,rn,tt.*from(        select *from emp order by sal desc    )tt where rownum&lt;11 ）where rn&gt;5;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2019/06/18/%E5%85%B3%E4%BA%8EMybatis%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <url>/2019/06/18/%E5%85%B3%E4%BA%8EMybatis%E7%9A%84%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="关于mybatis框架的自我反思总结"><a href="#关于mybatis框架的自我反思总结" class="headerlink" title="关于mybatis框架的自我反思总结"></a>关于mybatis框架的自我反思总结</h2><h3 id="Mbatis应用架构分析"><a href="#Mbatis应用架构分析" class="headerlink" title="Mbatis应用架构分析"></a>Mbatis应用架构分析</h3><p>Mybatis是一个非常优秀的持久层框架，它的底层时基于JDBC实现了与数据库之间的交互<br><br>并且在JDBC操作基础上做了封装和优化,它的应用架构如图所示。</p><p><img src="/img/mybatis-jdbc/yingyongjiagou.png" srcset="/img/loading.gif" alt="Alt mybatis应用架构图"></p><p>1.app可以是main方法，也可以是测试类在这个应用程序里，获取框架的api<br>2.任何一个框架都都会有对外的一组API，使用这样的API执行数据访问操作。<br>3.mybatis底层封装了JDBC。<br>4使用JDBC就需要驱动程序。</p><h4 id="为什么要使用mybatis来封装JDBC呢？"><a href="#为什么要使用mybatis来封装JDBC呢？" class="headerlink" title="为什么要使用mybatis来封装JDBC呢？"></a>为什么要使用mybatis来封装JDBC呢？</h4><p>在传统的JDBC中执行的性能还是很好的，但是操作的步骤比较的繁杂，<br>比如使用Statement发送sql的时候，就要给sql中的？（占位符）赋值，<br>然后发送给数据库执行sql，那么拿到一个结果的时候就要从结果集例取数据，然后映射到内存中的对象，过程比较复杂，并且重复代码很多。</p><p>说明：<br>Mybatis 之所以能够成为互联网项目中持久层应用的翘楚，个人认为其核心竞争<br>力应该是它灵活的 SQL 定制（动态sql），参数及结果集的映射。</p><h3 id="Mybatis产品架构分析"><a href="#Mybatis产品架构分析" class="headerlink" title="Mybatis产品架构分析"></a>Mybatis产品架构分析</h3><p>互联网项目中的任何一个框架都可以看成是一个产品，每个产品都有它自己的产品架构，Mybatis 也不例外，它的产品架构主要可以从接口应用，SQL 处理以及基础服务支撑等几个角度进行分析。如下图所示：<br><img src="/img/mybatis-jdbc/chanpinjiagou.png" srcset="/img/loading.gif" alt="Alt mybatis产品架构"><br>接口应用层：面向应用程序员。<br>sql处理层:对sql进行解析，对参数、结果集进行映射处理等。<br>基础服务层：</p>]]></content>
    
    
    <categories>
      
      <category>自我反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PL/SQL</title>
    <link href="/2019/05/14/PL_SQL_%E5%8F%98%E9%87%8F-%E6%B8%B8%E6%A0%87-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/05/14/PL_SQL_%E5%8F%98%E9%87%8F-%E6%B8%B8%E6%A0%87-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p> PL/SQL是是由甲骨文公司在90年代初开发，以提高SQL的功能。PL/SQL是嵌入在Oracle数据库中的编程语言之一。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。</p><a id="more"></a><h2 id="PL-SQL学习"><a href="#PL-SQL学习" class="headerlink" title="PL/SQL学习"></a>PL/SQL学习</h2><h3 id="PL-SQL-介绍"><a href="#PL-SQL-介绍" class="headerlink" title="PL/SQL 介绍"></a>PL/SQL 介绍</h3><p>&emsp; &emsp; PL/SQL是是由甲骨文公司在90年代初开发，以提高SQL的功能。PL/SQL是嵌入在Oracle数据库中的编程语言之一。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。</p><h3 id="PL-SQL-——Hello-World"><a href="#PL-SQL-——Hello-World" class="headerlink" title="PL/SQL ——Hello World"></a>PL/SQL ——Hello World</h3><pre><code>例：写一个简单的Hello Worlddeclare        //变量只能在这里声明    msg varchar(20);    //声明变量begin        //处理逻辑    msg := &apos;Hello world ! &apos;;    //赋值操作    dbms_output.put_line(msg);    //输出exception    -- 单行注释    /*     * 多行注释 ，这部分是异常处理模块，可有可无。     */end;</code></pre><p>##pl/sql编程语言<br></p><ul><li><p>p1/sq1编程语言是列sql语言的扩展,使待sql语言具有过程化编程的特性。<br></p></li><li><p>p1/sql编程语,比一般的过程化编程语言,更加灵活高效。<br></p></li><li><p>pl/sql编程语言主要用米编写存储过程和存储函数等。<br></p></li><li><p>时方法<br></p></li><li><p>赋值操作可以使用:也可以使用into查询语句默值<br></p><pre><code>declare    i number(2) := 10;    s varchar2(10) :=&apos;小明&apos;;    ena emp.ename%type;---引用型变量    emprow emp%rowtype;--记录型变量begin            dbms_output.put_line(i);        dbms_output.put_line (s);    select ename into ena from emp where empno =7788;        dbms_output.put_line (ena);    select * into emprow from emp where empno = 7788;        dbms_output.put_line (emprow.ename || &apos;的工作为:&apos; || emprow.job)end;    </code></pre></li></ul><p>###pl/sq1判断<br></p><ul><li><p>输入小于18的数字,输出未成年<br></p></li><li><p>输入大于18小于40的数字,输出中年人<br></p></li><li><p>输入大于40的数字,输出老年<br></p><pre><code>declare    i number(3) :=&amp;ii;begin        if i&lt;18 then            dbms_output.pu_line(&apos;未成年&apos;);     elseif i&lt;40 then            dbms_output.pu_line(&apos;中成年&apos;);    else i&lt;40            dbms_output.pu_line(&apos;老成年&apos;);    end if;end;</code></pre><p>###循环</p></li><li><p>–pl/sq1循环<br></p></li><li><p>–p1/sq1中的loop循环<br></p></li><li><p>–用三种方式输出1玛10是个数字<br></p></li><li><p>–while循环<br></p><pre><code>declare    i     number(2) :=1;begin    while i&lt;11 loop         dbms_output.putline (i);    i:=i+1;    end loop;end;</code></pre></li><li><p>–exit循环<br></p><p>   declare</p><pre><code>i     number(2) :=1;</code></pre><p>   begin</p><pre><code>loop exit while i&lt;11；      dbms_output.putline (i);i:=i+1;end loop;</code></pre><p>   end;</p></li><li><p>–for循环<br><br>   declare</p><p>   begin</p><pre><code>for i in 1..10 loop    dbms_output.put_line(in);end loop;</code></pre><p>   end;</p></li></ul><p>###游标</p><ul><li>可以存放个对象，多行记录</li></ul><p>输出emp表中所有员工的姓名</p><pre><code>declare            cursor c1 is select*from emp ;            emprow emp%rowtypebegin    open c1    loop          fetch c1 into emprow;         exit when c1%notfound;                dnms_output.put_line(emprow.name)    end loop; close c1;end;</code></pre><p>给指定部门员工涨工资</p><pre><code>declare    cursor c2(eno emp.deptno%type) is select*from emp where deptno = eno;    en emp.empno%typebegin    open c2(10)        loop            fetch c2 into en;            exit when c2%notfound;            update emp set sal =sal +100 wnere empno=en;         end loop;    close c2;end;</code></pre><p>###存储过程</p><ul><li><p>存储过程就是提前已经编译好的一段pl/sql，放置在数据库端</p></li><li><p>可以直接被调用。这一段pl/sql一般都是固定步骤的业务。<br>####语法</p><pre><code> create proc [ edure ] procedure_name [ ; number ]      [ { @parameter data_type }     [ varying ] [ = default ] [ output ]         ] [ ,...n ]      [ with{ recompile | encryption | recompile , encryption } ]      [ for replication ]      as sql_statement [ ...n ]</code></pre></li></ul><p style="background:yellow">参数    procedure_name<p style="color:red">案例</p></p>--给指定员工涨工资100<pre><code>pl语句    create or replace procedure p1(eno emp.empno%type)    is      begin        update emp set sal=sal+100 where empno=no;    commit;    end; 测试pl:    declare    begin    p1(7788);    end;</code></pre><p style="background:yellow">create 如果创建已经存在，会报一个错误 -‘对象已存在’create or replace 则不会报错，如果创建已存在，它会先删除原来的，然后创建你要创建的。</p><p>###存储函数<br>####语法<br>定义：函数唯一命名的存储程序，可带参数，并返回一计算值<br>函数和过程的结构类似，但必须有一个Return字句，用于返回函数值。</p><p>语法：</p><pre><code>create [or replace] function 函数名(参数列表)return 函数值类型asplsql子程序体;</code></pre><p style="color:red">案例</p></p>--通过存储函数实现计算指定员工的年薪<pre><code>pl语句    create or  replace fanction f_yearsal(eno emp.empno%type) return numberis    s number(10);begin    select sal*12+nvl(comm,0) from emp where empno=eno;     return s;end;测试f_yearsal:--存储函数调用的时候返回函数需要接收。declare    s number(10);begin    f_yearsal(7788);end;</code></pre><p>###out类型参数使用<br>    使用存储过程计算年薪<br>    create or replace procedure p_yearsal(eno emp.empno%type,yearsal out number)<br>    is<br>        s number(10);<br>        c emp.comm%type;<br>    begin<br>        select sal*12,nvl(comm) into s,c from emp where empno=eno;<br>        yearsal :=s+c;<br>    end;<br>    测试p_yearsal<br>    declare<br>    yearsal number(10);<br>    begin<br>    p_yearsal(7788,yearsal);<br>    end;</p><p style="background:yellow">in和out类型参数的区别是什么？    凡是涉及到into查询语句赋值或:=赋值操作的参数，必须使用out来修饰。</p><p>#####存储过程核存储函数的区别<br>相同点：1.创建语法结构相似，都可以携带多个传入参数和传出参数。</p><p>　　　　      2.都是一次编译，多次执行。</p><p>　　不同点：1.存储过程定义关键字用procedure，函数定义用function。</p><p>　　　　　　2.存储过程中不能用return返回值，但函数中可以，而且函数中必须有return子句。</p><p>　　　　　　3.执行方式略有不同，存储过程的执行方式有两种（1.使用execute2.使用begin和end），函数除了存储过程的两种方式外，还可以当做表达式使用，例如放在select中（select f1() form dual;）。</p><p>总结：如果只有一个返回值，用存储函数，否则，一般用存储过程。</p><p><a href="https://www.bilibili.com/video/BV1aE411K7u8?p=27" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1aE411K7u8?p=27</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>PL/SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本</title>
    <link href="/2019/05/14/Shell/"/>
    <url>/2019/05/14/Shell/</url>
    
    <content type="html"><![CDATA[<p>大数据程序员为什么要学习Shell呢？<br>需要看懂运维人员编写的Shell程序。<br>偶尔会编写一些简单Shell程序来管理集群、提高开发效率。</p><a id="more"></a><h3 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h3><p>大数据程序员为什么要学习Shell呢？<br></p><ul><li>1）需要看懂运维人员编写的Shell程序。<br></li><li>2）偶尔会编写一些简单Shell程序来管理集群、提高开发效率。<br></li></ul><h3 id="第2章-Shell解析器"><a href="#第2章-Shell解析器" class="headerlink" title="第2章 Shell解析器"></a>第2章 Shell解析器<br></h3><h4 id="（1）Linux提供的Shell解析器有："><a href="#（1）Linux提供的Shell解析器有：" class="headerlink" title="（1）Linux提供的Shell解析器有："></a>（1）Linux提供的Shell解析器有：</h4><pre><code>[atguigu@hadoop101 ~]$ cat /etc/shells /bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh</code></pre><h4 id="（2）bash和sh的关系"><a href="#（2）bash和sh的关系" class="headerlink" title="（2）bash和sh的关系"></a>（2）bash和sh的关系</h4><pre><code>[atguigu@hadoop101 bin]$ ll | grep bash-rwxr-xr-x. 1 root root 941880 5月  11 2016 bashlrwxrwxrwx. 1 root root  4 5月  27 2017 sh -&gt; bash</code></pre><h4 id="（3）Centos默认的解析器是bash"><a href="#（3）Centos默认的解析器是bash" class="headerlink" title="（3）Centos默认的解析器是bash"></a>（3）Centos默认的解析器是bash<br></h4><pre><code>[atguigu@hadoop102 bin]$ echo $SHELL/bin/bash</code></pre><h3 id="第3章-Shell脚本入门"><a href="#第3章-Shell脚本入门" class="headerlink" title="第3章 Shell脚本入门"></a>第3章 Shell脚本入门</h3><h4 id="1．脚本格式"><a href="#1．脚本格式" class="headerlink" title="1．脚本格式 "></a>1．脚本格式 <br></h4><pre><code>脚本以#!/bin/bash开头（指定解析器）</code></pre><h4 id="2．第一个Shell脚本：helloworld"><a href="#2．第一个Shell脚本：helloworld" class="headerlink" title="2．第一个Shell脚本：helloworld "></a>2．第一个Shell脚本：helloworld <br></h4><h5 id="（1）需求：创建一个Shell脚本，输出helloworld"><a href="#（1）需求：创建一个Shell脚本，输出helloworld" class="headerlink" title="（1）需求：创建一个Shell脚本，输出helloworld "></a>（1）需求：创建一个Shell脚本，输出helloworld <br></h5><h5 id="（2）案例实操："><a href="#（2）案例实操：" class="headerlink" title="（2）案例实操： "></a>（2）案例实操： <br></h5><pre><code>[atguigu@hadoop101 datas]$ touch helloworld.sh [atguigu@hadoop101 datas]$ vi helloworld.sh 在helloworld.sh中输入如下内容#!/bin/bashecho &quot;helloworld&quot;</code></pre><h5 id="（3）脚本的常用执行方式"><a href="#（3）脚本的常用执行方式" class="headerlink" title="（3）脚本的常用执行方式"></a>（3）脚本的常用执行方式<br></h5><ul><li>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）<br></li></ul><pre><code>sh+脚本的相对路径[atguigu@hadoop101 datas]$ sh helloworld.sh Helloworldsh+脚本的绝对路径[atguigu@hadoop101 datas]$ sh /home/atguigu/datas/helloworld.sh helloworldbash+脚本的相对路径[atguigu@hadoop101 datas]$ bash helloworld.sh Helloworldbash+脚本的绝对路径[atguigu@hadoop101 datas]$ bash /home/atguigu/datas/helloworld.sh Helloworld</code></pre><ul><li>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）<br><br>（a）首先要赋予helloworld.sh 脚本的+x权限<br></li></ul><pre><code>[atguigu@hadoop101 datas]$ chmod 777 helloworld.sh&lt;br&gt;</code></pre><p>（b）执行脚本<br></p><pre><code>相对路径    [atguigu@hadoop101 datas]$ ./helloworld.sh Helloworld绝对路径[atguigu@hadoop101 datas]$ /home/atguigu/datas/helloworld.sh Helloworld</code></pre><p>注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。<br><br>     第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。<br></p><h4 id="3．第二个Shell脚本：多命令处理"><a href="#3．第二个Shell脚本：多命令处理" class="headerlink" title="3．第二个Shell脚本：多命令处理"></a>3．第二个Shell脚本：多命令处理<br></h4><h5 id="（1）需求："><a href="#（1）需求：" class="headerlink" title="（1）需求： "></a>（1）需求： <br></h5><pre><code>在/home/atguigu/目录下创建一个banzhang.txt,在banzhang.txt文件中增加“I love cls”。&lt;br&gt;</code></pre><h5 id="（2）案例实操：-1"><a href="#（2）案例实操：-1" class="headerlink" title="（2）案例实操："></a>（2）案例实操：</h5><pre><code>[atguigu@hadoop101 datas]$ touch batch.sh[atguigu@hadoop101 datas]$ vi batch.sh在batch.sh中输入如下内容#!/bin/bashcd /home/atguigutouch cls.txtecho &quot;I love cls&quot; &gt;&gt;cls.txt</code></pre><h3 id="第4章-Shell中的变量"><a href="#第4章-Shell中的变量" class="headerlink" title="第4章 Shell中的变量"></a>第4章 Shell中的变量<br></h3><h4 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量<br></h4><h5 id="1-常用系统变量"><a href="#1-常用系统变量" class="headerlink" title="1. 常用系统变量"></a>1. 常用系统变量<br></h5><pre><code>$HOME、$PWD、$SHELL、$USER等</code></pre><h5 id="2．案例实操"><a href="#2．案例实操" class="headerlink" title="2．案例实操"></a>2．案例实操<br></h5><h6 id="（1）查看系统变量的值"><a href="#（1）查看系统变量的值" class="headerlink" title="（1）查看系统变量的值"></a>（1）查看系统变量的值<br></h6><pre><code>[atguigu@hadoop101 datas]$ echo $HOME/home/atguigu</code></pre><h6 id="（2）显示当前Shell中所有变量：set"><a href="#（2）显示当前Shell中所有变量：set" class="headerlink" title="（2）显示当前Shell中所有变量：set"></a>（2）显示当前Shell中所有变量：set<br></h6><pre><code>[atguigu@hadoop101 datas]$ setBASH=/bin/bashBASH_ALIASES=()BASH_ARGC=()BASH_ARGV=()</code></pre><h4 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2 自定义变量"></a>4.2 自定义变量<br></h4><h5 id="1．基本语法"><a href="#1．基本语法" class="headerlink" title="1．基本语法"></a>1．基本语法<br></h5><pre><code>（1）定义变量：变量=值 &lt;br&gt;（2）撤销变量：unset 变量&lt;br&gt;（3）声明静态变量：readonly变量，注意：不能unset&lt;br&gt;</code></pre><h5 id="2．变量定义规则"><a href="#2．变量定义规则" class="headerlink" title="2．变量定义规则"></a>2．变量定义规则<br></h5><pre><code>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。（2）等号两侧不能有空格（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。（4）变量的值如果有空格，需要使用双引号或单引号括起来。</code></pre><h5 id="3．案例实操"><a href="#3．案例实操" class="headerlink" title="3．案例实操"></a>3．案例实操<br></h5><h6 id="（1）定义变量A"><a href="#（1）定义变量A" class="headerlink" title="（1）定义变量A"></a>（1）定义变量A<br></h6><pre><code>[atguigu@hadoop101 datas]$ A=5[atguigu@hadoop101 datas]$ echo $A5</code></pre><h6 id="（2）给变量A重新赋值"><a href="#（2）给变量A重新赋值" class="headerlink" title="（2）给变量A重新赋值"></a>（2）给变量A重新赋值</h6><pre><code>[atguigu@hadoop101 datas]$ A=8[atguigu@hadoop101 datas]$ echo $A8</code></pre><h6 id="（3）撤销变量A"><a href="#（3）撤销变量A" class="headerlink" title="（3）撤销变量A"></a>（3）撤销变量A</h6><pre><code>[atguigu@hadoop101 datas]$ unset A[atguigu@hadoop101 datas]$ echo $A</code></pre><h6 id="（4）声明静态的变量B-2，不能unset"><a href="#（4）声明静态的变量B-2，不能unset" class="headerlink" title="（4）声明静态的变量B=2，不能unset"></a>（4）声明静态的变量B=2，不能unset</h6><pre><code>[atguigu@hadoop101 datas]$ readonly B=2[atguigu@hadoop101 datas]$ echo $B2[atguigu@hadoop101 datas]$ B=9-bash: B: readonly variable</code></pre><h6 id="（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算"><a href="#（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算" class="headerlink" title="（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算"></a>（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</h6><pre><code>[atguigu@hadoop102 ~]$ C=1+2[atguigu@hadoop102 ~]$ echo $C1+2</code></pre><h6 id="（6）变量的值如果有空格，需要使用双引号或单引号括起来"><a href="#（6）变量的值如果有空格，需要使用双引号或单引号括起来" class="headerlink" title="（6）变量的值如果有空格，需要使用双引号或单引号括起来"></a>（6）变量的值如果有空格，需要使用双引号或单引号括起来</h6><pre><code>[atguigu@hadoop102 ~]$ D=I love banzhang-bash: world: command not found[atguigu@hadoop102 ~]$ D=&quot;I love banzhang&quot;[atguigu@hadoop102 ~]$ echo $AI love banzhang</code></pre><h6 id="（7）可把变量提升为全局环境变量，可供其他Shell程序使用"><a href="#（7）可把变量提升为全局环境变量，可供其他Shell程序使用" class="headerlink" title="（7）可把变量提升为全局环境变量，可供其他Shell程序使用"></a>（7）可把变量提升为全局环境变量，可供其他Shell程序使用</h6><h4 id="export-变量名"><a href="#export-变量名" class="headerlink" title="export 变量名"></a>export 变量名</h4><pre><code>[atguigu@hadoop101 datas]$ vim helloworld.sh 在helloworld.sh文件中增加echo $B#!/bin/bashecho &quot;helloworld&quot;echo $B[atguigu@hadoop101 datas]$ ./helloworld.sh Helloworld发现并没有打印输出变量B的值。[atguigu@hadoop101 datas]$ export B[atguigu@hadoop101 datas]$ ./helloworld.sh helloworld2</code></pre><h4 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n<br></h4><h5 id="1．基本语法-1"><a href="#1．基本语法-1" class="headerlink" title="1．基本语法"></a>1．基本语法<br></h5><pre><code>$n    （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）</code></pre><h5 id="2．案例实操-1"><a href="#2．案例实操-1" class="headerlink" title="2．案例实操"></a>2．案例实操<br></h5><h6 id="（1）输出该脚本文件名称、输入参数1和输入参数2-的值"><a href="#（1）输出该脚本文件名称、输入参数1和输入参数2-的值" class="headerlink" title="（1）输出该脚本文件名称、输入参数1和输入参数2 的值"></a>（1）输出该脚本文件名称、输入参数1和输入参数2 的值<br></h6><pre><code>[atguigu@hadoop101 datas]$ touch parameter.sh [atguigu@hadoop101 datas]$ vim parameter.sh#!/bin/bashecho &quot;$0  $1   $2&quot;[atguigu@hadoop101 datas]$ chmod 777 parameter.sh[atguigu@hadoop101 datas]$ ./parameter.sh cls  xz./parameter.sh  cls   xz</code></pre><h4 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$#"></a>4.4 特殊变量：$#<br></h4><h5 id="1．基本语法-2"><a href="#1．基本语法-2" class="headerlink" title="1．基本语法"></a>1．基本语法</h5><pre><code>$#    （功能描述：获取所有输入参数个数，常用于循环）。</code></pre><h5 id="2．案例实操-2"><a href="#2．案例实操-2" class="headerlink" title="2．案例实操"></a>2．案例实操<br></h5><h6 id="（1）获取输入参数的个数"><a href="#（1）获取输入参数的个数" class="headerlink" title="（1）获取输入参数的个数"></a>（1）获取输入参数的个数</h6><pre><code>[atguigu@hadoop101 datas]$ vim parameter.sh#!/bin/bashecho &quot;$0  $1   $2&quot;echo $#[atguigu@hadoop101 datas]$ chmod 777 parameter.sh[atguigu@hadoop101 datas]$ ./parameter.sh cls  xz    parameter.sh cls xz     2</code></pre><h4 id="4-5-特殊变量：-、"><a href="#4-5-特殊变量：-、" class="headerlink" title="4.5 特殊变量：$*、$@"></a>4.5 特殊变量：$*、$@<br></h4><h5 id="1．基本语法-3"><a href="#1．基本语法-3" class="headerlink" title="1．基本语法"></a>1．基本语法<br></h5><pre><code>$*    （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）&lt;br&gt;$@    （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</code></pre><h5 id="2．案例实操-3"><a href="#2．案例实操-3" class="headerlink" title="2．案例实操"></a>2．案例实操</h5><h6 id="（1）打印输入的所有参数"><a href="#（1）打印输入的所有参数" class="headerlink" title="（1）打印输入的所有参数"></a>（1）打印输入的所有参数</h6><pre><code>[atguigu@hadoop101 datas]$ vim parameter.sh#!/bin/bash    echo &quot;$0  $1   $2&quot;    echo $#    echo $*    echo $@[atguigu@hadoop101 datas]$ bash parameter.sh 1 2 3    parameter.sh  1   2    3    1 2 3    1 2 3</code></pre><h4 id="4-6-特殊变量：-？"><a href="#4-6-特殊变量：-？" class="headerlink" title="4.6 特殊变量：$？"></a>4.6 特殊变量：$？<br></h4><h5 id="1．基本语法-4"><a href="#1．基本语法-4" class="headerlink" title="1．基本语法"></a>1．基本语法<br></h5><p>$？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；<br><br>如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）<br>#####2．案例实操<br></p><pre><code>（1）判断helloworld.sh脚本是否正确执行[atguigu@hadoop101 datas]$ ./helloworld.sh hello world[atguigu@hadoop101 datas]$ echo $?0</code></pre><h3 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符    "></a>第5章 运算符    <br></h3><h4 id="1．基本语法-5"><a href="#1．基本语法-5" class="headerlink" title="1．基本语法"></a>1．基本语法<br></h4><h5 id="（1）“-运算式-”或“-运算式-”"><a href="#（1）“-运算式-”或“-运算式-”" class="headerlink" title="（1）“$((运算式))”或“$[运算式]”"></a>（1）“$((运算式))”或“$[运算式]”<br></h5><h5 id="（2）expr-加，减，乘，除，取余"><a href="#（2）expr-加，减，乘，除，取余" class="headerlink" title="（2）expr  + , - , *,  /,  %    加，减，乘，除，取余"></a>（2）expr  + , - , *,  /,  %    加，减，乘，除，取余<br></h5><pre><code>注意：expr运算符间要有空格</code></pre><h4 id="2．案例实操："><a href="#2．案例实操：" class="headerlink" title="2．案例实操："></a>2．案例实操：</h4><h5 id="（1）计算3-2的值"><a href="#（1）计算3-2的值" class="headerlink" title="（1）计算3+2的值"></a>（1）计算3+2的值</h5><pre><code>[atguigu@hadoop101 datas]$ expr 2 + 35</code></pre><h5 id="（2）计算3-2的值"><a href="#（2）计算3-2的值" class="headerlink" title="（2）计算3-2的值"></a>（2）计算3-2的值</h5><pre><code>[atguigu@hadoop101 datas]$ expr 3 - 2 1</code></pre><h5 id="（3）计算（2-3）X4的值"><a href="#（3）计算（2-3）X4的值" class="headerlink" title="（3）计算（2+3）X4的值"></a>（3）计算（2+3）X4的值</h5><pre><code>（a）expr一步完成计算    [atguigu@hadoop101 datas]$ expr `expr 2 + 3` \* 4    20（b）采用$[运算式]方式    [atguigu@hadoop101 datas]# S=$[(2+3)*4]    [atguigu@hadoop101 datas]# echo $S</code></pre><h3 id="第6章-条件判断"><a href="#第6章-条件判断" class="headerlink" title="第6章 条件判断"></a>第6章 条件判断</h3><h4 id="1．基本语法-6"><a href="#1．基本语法-6" class="headerlink" title="1．基本语法"></a>1．基本语法</h4><pre><code>[ condition ]（注意condition前后要有空格）注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。</code></pre><h4 id="2-常用判断条件"><a href="#2-常用判断条件" class="headerlink" title="2. 常用判断条件"></a>2. 常用判断条件</h4><h5 id="（1）两个整数之间比较"><a href="#（1）两个整数之间比较" class="headerlink" title="（1）两个整数之间比较"></a>（1）两个整数之间比较</h5><pre><code>= 字符串比较-lt 小于（less than）            -le 小于等于（less equal）-eq 等于（equal）                -gt 大于（greater than）-ge 大于等于（greater equal）    -ne 不等于（Not equal）</code></pre><h5 id="（2）按照文件权限进行判断"><a href="#（2）按照文件权限进行判断" class="headerlink" title="（2）按照文件权限进行判断"></a>（2）按照文件权限进行判断</h5><pre><code>-r 有读的权限（read）            -w 有写的权限（write）-x 有执行的权限（execute）</code></pre><h5 id="（3）按照文件类型进行判断"><a href="#（3）按照文件类型进行判断" class="headerlink" title="（3）按照文件类型进行判断"></a>（3）按照文件类型进行判断</h5><pre><code>-f 文件存在并且是一个常规的文件（file）-e 文件存在（existence）        -d 文件存在并是一个目录（directory）</code></pre><h4 id="3．案例实操-1"><a href="#3．案例实操-1" class="headerlink" title="3．案例实操"></a>3．案例实操</h4><h5 id="（1）23是否大于等于22"><a href="#（1）23是否大于等于22" class="headerlink" title="（1）23是否大于等于22"></a>（1）23是否大于等于22</h5><pre><code>[atguigu@hadoop101 datas]$ [ 23 -ge 22 ][atguigu@hadoop101 datas]$ echo $?0</code></pre><h5 id="（2）helloworld-sh是否具有写权限"><a href="#（2）helloworld-sh是否具有写权限" class="headerlink" title="（2）helloworld.sh是否具有写权限"></a>（2）helloworld.sh是否具有写权限</h5><pre><code>[atguigu@hadoop101 datas]$ [ -w helloworld.sh ][atguigu@hadoop101 datas]$ echo $?0</code></pre><h5 id="（3）-home-atguigu-cls-txt目录中的文件是否存在"><a href="#（3）-home-atguigu-cls-txt目录中的文件是否存在" class="headerlink" title="（3）/home/atguigu/cls.txt目录中的文件是否存在"></a>（3）/home/atguigu/cls.txt目录中的文件是否存在</h5><pre><code>[atguigu@hadoop101 datas]$ [ -e /home/b.txt ][atguigu@hadoop101 datas]$ echo $?1</code></pre><h5 id="（4）多条件判断（-amp-amp-表示前一条命令执行成功时，才执行后一条命令，-表示上一条命令执行失败后，才执行下一条命令）"><a href="#（4）多条件判断（-amp-amp-表示前一条命令执行成功时，才执行后一条命令，-表示上一条命令执行失败后，才执行下一条命令）" class="headerlink" title="（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）"></a>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）</h5><pre><code>[atguigu@hadoop101 ~]$ [ condition ] &amp;&amp; echo OK || echo notokOK[atguigu@hadoop101 datas]$ [ condition ] &amp;&amp; [ ] || echo notoknotok</code></pre><h3 id="第7章-流程控制（重点）"><a href="#第7章-流程控制（重点）" class="headerlink" title="第7章 流程控制（重点）"></a>第7章 流程控制（重点）</h3><h4 id="7-1-if-判断"><a href="#7-1-if-判断" class="headerlink" title="7.1 if 判断"></a>7.1 if 判断</h4><h5 id="1．基本语法-7"><a href="#1．基本语法-7" class="headerlink" title="1．基本语法"></a>1．基本语法</h5><pre><code>if [ 条件判断式 ];then   程序 fi 或者 if [ 条件判断式 ]   then     程序 fi</code></pre><p>注意事项：<br>（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格<br>（2）if后要有空格</p><h5 id="2．案例实操-4"><a href="#2．案例实操-4" class="headerlink" title="2．案例实操"></a>2．案例实操</h5><p>（1）输入一个数字，如果是1，则输出banzhang zhen shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。</p><pre><code>[atguigu@hadoop101 datas]$ touch if.sh[atguigu@hadoop101 datas]$ vim if.sh#!/bin/bashif [ $1 -eq &quot;1&quot; ]then        echo &quot;banzhang zhen shuai&quot;elif [ $1 -eq &quot;2&quot; ]then        echo &quot;cls zhen mei&quot;fi[atguigu@hadoop101 datas]$ chmod 777 if.sh [atguigu@hadoop101 datas]$ ./if.sh 1banzhang zhen shuai</code></pre><h4 id="7-2-case-语句"><a href="#7-2-case-语句" class="headerlink" title="7.2 case 语句"></a>7.2 case 语句</h4><h5 id="1．基本语法-8"><a href="#1．基本语法-8" class="headerlink" title="1．基本语法"></a>1．基本语法</h5><pre><code>case $变量名 in   &quot;值1&quot;）     如果变量的值等于值1，则执行程序1     ;;   &quot;值2&quot;）     如果变量的值等于值2，则执行程序2     ;;   …省略其他分支…   *）     如果变量的值都不是以上的值，则执行此程序     ;; esac</code></pre><p>注意事项：</p><p>1)    case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。<br>2)    双分号“;;”表示命令序列结束，相当于java中的break。<br>3)    最后的“*）”表示默认模式，相当于java中的default。</p><h5 id="2．案例实操-5"><a href="#2．案例实操-5" class="headerlink" title="2．案例实操"></a>2．案例实操</h5><p>（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。</p><pre><code>[atguigu@hadoop101 datas]$ touch case.sh[atguigu@hadoop101 datas]$ vim case.sh!/bin/bashcase $1 in&quot;1&quot;)        echo &quot;banzhang&quot;;;&quot;2&quot;)        echo &quot;cls&quot;;;*)        echo &quot;renyao&quot;;;esac[atguigu@hadoop101 datas]$ chmod 777 case.sh[atguigu@hadoop101 datas]$ ./case.sh 11</code></pre><h4 id="7-3-for-循环"><a href="#7-3-for-循环" class="headerlink" title="7.3 for 循环"></a>7.3 for 循环</h4><h5 id="1．基本语法1"><a href="#1．基本语法1" class="headerlink" title="1．基本语法1"></a>1．基本语法1</h5><pre><code>for (( 初始值;循环控制条件;变量变化 )) do   程序 done</code></pre><h5 id="2．案例实操-6"><a href="#2．案例实操-6" class="headerlink" title="2．案例实操"></a>2．案例实操</h5><h6 id="（1）从1加到100"><a href="#（1）从1加到100" class="headerlink" title="（1）从1加到100"></a>（1）从1加到100</h6><pre><code>[atguigu@hadoop101 datas]$ touch for1.sh[atguigu@hadoop101 datas]$ vim for1.sh#!/bin/bashs=0for((i=0;i&lt;=100;i++))do        s=$[$s+$i]doneecho $s[atguigu@hadoop101 datas]$ chmod 777 for1.sh [atguigu@hadoop101 datas]$ ./for1.sh “5050”</code></pre><h5 id="3．基本语法2"><a href="#3．基本语法2" class="headerlink" title="3．基本语法2"></a>3．基本语法2</h5><pre><code>for 变量 in 值1 值2 值3…   do     程序   done</code></pre><h5 id="4．案例实操"><a href="#4．案例实操" class="headerlink" title="4．案例实操"></a>4．案例实操</h5><h6 id="（1）打印所有输入参数"><a href="#（1）打印所有输入参数" class="headerlink" title="（1）打印所有输入参数"></a>（1）打印所有输入参数</h6><pre><code>[atguigu@hadoop101 datas]$ touch for2.sh[atguigu@hadoop101 datas]$ vim for2.sh#!/bin/bash#打印数字for i in $*    do      echo &quot;ban zhang love $i &quot;    done[atguigu@hadoop101 datas]$ chmod 777 for2.sh [atguigu@hadoop101 datas]$ bash for2.sh cls xz bdban zhang love clsban zhang love xzban zhang love bd</code></pre><h6 id="（2）比较-和-区别"><a href="#（2）比较-和-区别" class="headerlink" title="（2）比较$*和$@区别"></a>（2）比较$*和$@区别</h6><p>（a）$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n的形式输出所有参数。</p><pre><code>[atguigu@hadoop101 datas]$ touch for.sh[atguigu@hadoop101 datas]$ vim for.sh#!/bin/bash for i in $*do      echo &quot;ban zhang love $i &quot;donefor j in $@do              echo &quot;ban zhang love $j&quot;done[atguigu@hadoop101 datas]$ bash for.sh cls xz bdban zhang love cls ban zhang love xz ban zhang love bd ban zhang love clsban zhang love xzban zhang love bd</code></pre><p>（b）当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输出所有参数；<br><br>“$@”会将各个参数分开，以“$1” “$2”…”$n”的形式输出所有参数。</p><pre><code>[atguigu@hadoop101 datas]$ vim for.sh#!/bin/bash for i in &quot;$*&quot; #$*中的所有参数看成是一个整体，所以这个for循环只会循环一次         do                 echo &quot;ban zhang love $i&quot;        done for j in &quot;$@&quot; #$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次         do                 echo &quot;ban zhang love $j&quot; done[atguigu@hadoop101 datas]$ chmod 777 for.sh[atguigu@hadoop101 datas]$ bash for.sh cls xz bdban zhang love cls xz bdban zhang love clsban zhang love xzban zhang love bd</code></pre><h4 id="7-4-while-循环"><a href="#7-4-while-循环" class="headerlink" title="7.4 while 循环"></a>7.4 while 循环</h4><h5 id="1．基本语法-9"><a href="#1．基本语法-9" class="headerlink" title="1．基本语法"></a>1．基本语法</h5><pre><code>while [ 条件判断式 ]   do     程序  done</code></pre><h5 id="2．案例实操-7"><a href="#2．案例实操-7" class="headerlink" title="2．案例实操"></a>2．案例实操</h5><pre><code>（1）从1加到100[atguigu@hadoop101 datas]$ touch while.sh[atguigu@hadoop101 datas]$ vim while.sh#!/bin/bashs=0i=1while [ $i -le 100 ]do        s=$[$s+$i]        i=$[$i+1]doneecho $s[atguigu@hadoop101 datas]$ chmod 777 while.sh [atguigu@hadoop101 datas]$ ./while.sh 5050</code></pre><h3 id="第8章-read读取控制台输入"><a href="#第8章-read读取控制台输入" class="headerlink" title="第8章 read读取控制台输入"></a>第8章 read读取控制台输入</h3><h4 id="1．基本语法-10"><a href="#1．基本语法-10" class="headerlink" title="1．基本语法"></a>1．基本语法</h4><pre><code>    read(选项)(参数)    选项：-p：指定读取值时的提示符；-t：指定读取值时等待的时间（秒）。参数    变量：指定读取值的变量名</code></pre><h4 id="2．案例实操-8"><a href="#2．案例实操-8" class="headerlink" title="2．案例实操"></a>2．案例实操</h4><h5 id="（1）提示7秒内，读取控制台输入的名称"><a href="#（1）提示7秒内，读取控制台输入的名称" class="headerlink" title="（1）提示7秒内，读取控制台输入的名称"></a>（1）提示7秒内，读取控制台输入的名称</h5><pre><code>[atguigu@hadoop101 datas]$ touch read.sh[atguigu@hadoop101 datas]$ vim read.sh#!/bin/bashread -t 7 -p &quot;Enter your name in 7 seconds &quot; NAMEecho $NAME[atguigu@hadoop101 datas]$ ./read.sh Enter your name in 7 seconds xiaozexiaoze</code></pre><h3 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h3><h4 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h4><h5 id="1．basename基本语法"><a href="#1．basename基本语法" class="headerlink" title="1．basename基本语法"></a>1．basename基本语法</h5><pre><code>basename [string / pathname] [suffix]      （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</code></pre><h5 id="2．案例实操-9"><a href="#2．案例实操-9" class="headerlink" title="2．案例实操"></a>2．案例实操</h5><p>（1）截取该/home/atguigu/banzhang.txt路径的文件名称</p><pre><code>[atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt banzhang.txt[atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txtbanzhang</code></pre><h5 id="3-dirname基本语法"><a href="#3-dirname基本语法" class="headerlink" title="3.    dirname基本语法"></a>3.    dirname基本语法</h5><pre><code>dirname 文件绝对路径（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</code></pre><h5 id="4．案例实操-1"><a href="#4．案例实操-1" class="headerlink" title="4．案例实操"></a>4．案例实操</h5><h6 id="（1）获取banzhang-txt文件的路径"><a href="#（1）获取banzhang-txt文件的路径" class="headerlink" title="（1）获取banzhang.txt文件的路径"></a>（1）获取banzhang.txt文件的路径</h6><pre><code>[atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt /home/atguigu</code></pre><h4 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h4><h5 id="1．基本语法-11"><a href="#1．基本语法-11" class="headerlink" title="1．基本语法"></a>1．基本语法</h5><pre><code>[ function ] funname[()]{    Action;    [return int;]}funname</code></pre><h5 id="2．经验技巧"><a href="#2．经验技巧" class="headerlink" title="2．经验技巧"></a>2．经验技巧</h5><pre><code>（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。（2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)</code></pre><h5 id="3．案例实操-2"><a href="#3．案例实操-2" class="headerlink" title="3．案例实操"></a>3．案例实操</h5><p>（1）计算两个输入参数的和</p><pre><code>[atguigu@hadoop101 datas]$ touch fun.sh[atguigu@hadoop101 datas]$ vim fun.sh#!/bin/bashfunction sum(){    s=0    s=$[ $1 + $2 ]    echo &quot;$s&quot;}read -p &quot;Please input the number1: &quot; n1;read -p &quot;Please input the number2: &quot; n2;sum $n1 $n2;[atguigu@hadoop101 datas]$ chmod 777 fun.sh[atguigu@hadoop101 datas]$ ./fun.sh Please input the number1: 2Please input the number2: 57</code></pre><h3 id="第10章-Shell工具（重点）"><a href="#第10章-Shell工具（重点）" class="headerlink" title="第10章 Shell工具（重点）"></a>第10章 Shell工具（重点）</h3><h4 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h4><p>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><h5 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h5><p>cut [选项参数]  filename<br>说明：默认分隔符是制表符</p><h5 id="2-选项参数说明"><a href="#2-选项参数说明" class="headerlink" title="2.选项参数说明"></a>2.选项参数说明</h5><p>表1-55<br>选项参数    功能<br>-f    列号，提取第几列<br>-d    分隔符，按照指定分隔符分割列</p><h5 id="3-案例实操"><a href="#3-案例实操" class="headerlink" title="3.案例实操"></a>3.案例实操</h5><h6 id="（0）数据准备"><a href="#（0）数据准备" class="headerlink" title="（0）数据准备"></a>（0）数据准备</h6><pre><code>[atguigu@hadoop101 datas]$ touch cut.txt[atguigu@hadoop101 datas]$ vim cut.txtdong shenguan zhenwo  wolai  laile  le</code></pre><h6 id="（1）切割cut-txt第一列"><a href="#（1）切割cut-txt第一列" class="headerlink" title="（1）切割cut.txt第一列"></a>（1）切割cut.txt第一列</h6><pre><code>[atguigu@hadoop101 datas]$ cut -d &quot; &quot; -f 1 cut.txt dongguanwolaile</code></pre><h6 id="（2）切割cut-txt第二、三列"><a href="#（2）切割cut-txt第二、三列" class="headerlink" title="（2）切割cut.txt第二、三列"></a>（2）切割cut.txt第二、三列</h6><pre><code>[atguigu@hadoop101 datas]$ cut -d &quot; &quot; -f 2,3 cut.txt shenzhen wo lai le</code></pre><h6 id="（3）在cut-txt文件中切割出guan"><a href="#（3）在cut-txt文件中切割出guan" class="headerlink" title="（3）在cut.txt文件中切割出guan"></a>（3）在cut.txt文件中切割出guan</h6><pre><code>[atguigu@hadoop101 datas]$ cat cut.txt | grep &quot;guan&quot; | cut -d &quot; &quot; -f 1guan</code></pre><h6 id="（4）选取系统PATH变量值，第2个“：”开始后的所有路径："><a href="#（4）选取系统PATH变量值，第2个“：”开始后的所有路径：" class="headerlink" title="（4）选取系统PATH变量值，第2个“：”开始后的所有路径："></a>（4）选取系统PATH变量值，第2个“：”开始后的所有路径：</h6><pre><code>[atguigu@hadoop101 datas]$ echo $PATH/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin[atguigu@hadoop102 datas]$ echo $PATH | cut -d: -f 2-/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</code></pre><h6 id="（5）切割ifconfig-后打印的IP地址"><a href="#（5）切割ifconfig-后打印的IP地址" class="headerlink" title="（5）切割ifconfig 后打印的IP地址"></a>（5）切割ifconfig 后打印的IP地址</h6><pre><code>[atguigu@hadoop101 datas]$ ifconfig eth0 | grep &quot;inet addr&quot; | cut -d: -f 2 | cut -d&quot; &quot; -f1192.168.1.102</code></pre><h4 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h4><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><h5 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1.    基本用法"></a>1.    基本用法</h5><p>sed [选项参数]  ‘command’  filename</p><h5 id="2-选项参数说明-1"><a href="#2-选项参数说明-1" class="headerlink" title="2.    选项参数说明"></a>2.    选项参数说明</h5><pre><code>表1-56选项参数    功能-e    直接在指令列模式上进行sed的动作编辑。</code></pre><h5 id="3-命令功能描述"><a href="#3-命令功能描述" class="headerlink" title="3.    命令功能描述"></a>3.    命令功能描述</h5><pre><code>表1-57命令    功能描述a     新增，a的后面可以接字串，在下一行出现d    删除s    查找并替换 4.    案例实操</code></pre><h6 id="（0）数据准备-1"><a href="#（0）数据准备-1" class="headerlink" title="（0）数据准备"></a>（0）数据准备</h6><pre><code>[atguigu@hadoop102 datas]$ touch sed.txt[atguigu@hadoop102 datas]$ vim sed.txtdong shenguan zhenwo  wolai  laile  le</code></pre><h6 id="（1）将“mei-nv”这个单词插入到sed-txt第二行下，打印。"><a href="#（1）将“mei-nv”这个单词插入到sed-txt第二行下，打印。" class="headerlink" title="（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。"></a>（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。</h6><pre><code>[atguigu@hadoop102 datas]$ sed &apos;2a mei nv&apos; sed.txt dong shenguan zhenmei nvwo  wolai  laile  le[atguigu@hadoop102 datas]$ cat sed.txt dong shenguan zhenwo  wolai  laile  le注意：文件并没有改变</code></pre><h6 id="（2）删除sed-txt文件所有包含wo的行"><a href="#（2）删除sed-txt文件所有包含wo的行" class="headerlink" title="（2）删除sed.txt文件所有包含wo的行"></a>（2）删除sed.txt文件所有包含wo的行</h6><pre><code>[atguigu@hadoop102 datas]$ sed &apos;/wo/d&apos; sed.txtdong shenguan zhenlai  laile  le</code></pre><h6 id="（3）将sed-txt文件中wo替换为ni"><a href="#（3）将sed-txt文件中wo替换为ni" class="headerlink" title="（3）将sed.txt文件中wo替换为ni"></a>（3）将sed.txt文件中wo替换为ni</h6><pre><code>[atguigu@hadoop102 datas]$ sed &apos;s/wo/ni/g&apos; sed.txt dong shenguan zhenni  nilai  laile  le注意：‘g’表示global，全部替换</code></pre><h6 id="（4）将sed-txt文件中的第二行删除并将wo替换为ni"><a href="#（4）将sed-txt文件中的第二行删除并将wo替换为ni" class="headerlink" title="（4）将sed.txt文件中的第二行删除并将wo替换为ni"></a>（4）将sed.txt文件中的第二行删除并将wo替换为ni</h6><pre><code>[atguigu@hadoop102 datas]$ sed -e &apos;2d&apos; -e &apos;s/wo/ni/g&apos; sed.txt dong shenni  nilai  laile  le</code></pre><h4 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><h5 id="1-基本用法-2"><a href="#1-基本用法-2" class="headerlink" title="1.    基本用法"></a>1.    基本用法</h5><pre><code>awk [选项参数] ‘pattern1{action1}  pattern2{action2}...’ filenamepattern：表示AWK在数据中查找的内容，就是匹配模式action：在找到匹配内容时所执行的一系列命令</code></pre><h5 id="2-选项参数说明-2"><a href="#2-选项参数说明-2" class="headerlink" title="2.    选项参数说明"></a>2.    选项参数说明</h5><pre><code>表1-55选项参数    功能-F    指定输入文件折分隔符-v    赋值一个用户定义变量</code></pre><h5 id="3-案例实操-1"><a href="#3-案例实操-1" class="headerlink" title="3.    案例实操"></a>3.    案例实操</h5><h6 id="（0）数据准备-2"><a href="#（0）数据准备-2" class="headerlink" title="（0）数据准备"></a>（0）数据准备</h6><pre><code>[atguigu@hadoop102 datas]$ sudo cp /etc/passwd ./</code></pre><h6 id="（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。"><a href="#（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。" class="headerlink" title="（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。"></a>（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</h6><pre><code>[atguigu@hadoop102 datas]$ awk -F: &apos;/^root/{print $7}&apos; passwd /bin/bash</code></pre><h6 id="（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。"><a href="#（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。" class="headerlink" title="（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。"></a>（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。</h6><pre><code>[atguigu@hadoop102 datas]$ awk -F: &apos;/^root/{print $1&quot;,&quot;$7}&apos; passwd root,/bin/bash注意：只有匹配了pattern的行才会执行action</code></pre><h6 id="（3）只显示-etc-passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，-bin-zuishuai”。"><a href="#（3）只显示-etc-passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，-bin-zuishuai”。" class="headerlink" title="（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。"></a>（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。</h6><pre><code>[atguigu@hadoop102 datas]$ awk -F : &apos;BEGIN{print &quot;user, shell&quot;} {print $1&quot;,&quot;$7} END{print &quot;dahaige,/bin/zuishuai&quot;}&apos; passwduser, shellroot,/bin/bashbin,/sbin/nologin。。。atguigu,/bin/bashdahaige,/bin/zuishuai注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</code></pre><h6 id="（4）将passwd文件中的用户id增加数值1并输出"><a href="#（4）将passwd文件中的用户id增加数值1并输出" class="headerlink" title="（4）将passwd文件中的用户id增加数值1并输出"></a>（4）将passwd文件中的用户id增加数值1并输出</h6><pre><code>[atguigu@hadoop102 datas]$ awk -v i=1 -F: &apos;{print $3+i}&apos; passwd1234</code></pre><h5 id="4-awk的内置变量"><a href="#4-awk的内置变量" class="headerlink" title="4.    awk的内置变量"></a>4.    awk的内置变量</h5><pre><code>表1-56变量    说明FILENAME    文件名NR    已读的记录数NF    浏览记录的域的个数（切割后，列的个数）</code></pre><h5 id="5-案例实操"><a href="#5-案例实操" class="headerlink" title="5.    案例实操"></a>5.    案例实操</h5><h6 id="（1）统计passwd文件名，每行的行号，每行的列数"><a href="#（1）统计passwd文件名，每行的行号，每行的列数" class="headerlink" title="（1）统计passwd文件名，每行的行号，每行的列数"></a>（1）统计passwd文件名，每行的行号，每行的列数</h6><pre><code>[atguigu@hadoop102 datas]$ awk -F: &apos;{print &quot;filename:&quot;  FILENAME &quot;, linenumber:&quot; NR  &quot;,columns:&quot; NF}&apos; passwd filename:passwd, linenumber:1,columns:7filename:passwd, linenumber:2,columns:7filename:passwd, linenumber:3,columns:7</code></pre><h6 id="（2）切割IP"><a href="#（2）切割IP" class="headerlink" title="（2）切割IP"></a>（2）切割IP</h6><pre><code>[atguigu@hadoop102 datas]$ ifconfig eth0 | grep &quot;inet addr&quot; | awk -F: &apos;{print $2}&apos; | awk -F &quot; &quot; &apos;{print $1}&apos; 192.168.1.102</code></pre><h6 id="（3）查询sed-txt中空行所在的行号"><a href="#（3）查询sed-txt中空行所在的行号" class="headerlink" title="（3）查询sed.txt中空行所在的行号"></a>（3）查询sed.txt中空行所在的行号</h6><pre><code>[atguigu@hadoop102 datas]$ awk &apos;/^$/{print NR}&apos; sed.txt 5</code></pre><h4 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p><h5 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.    基本语法"></a>1.    基本语法</h5><pre><code>sort(选项)(参数)表1-57选项    说明-n    依照数值的大小排序-r    以相反的顺序来排序-t    设置排序时所用的分隔字符-k    指定需要排序的列参数：指定待排序的文件列表</code></pre><h5 id="2-案例实操"><a href="#2-案例实操" class="headerlink" title="2. 案例实操"></a>2. 案例实操</h5><h6 id="（0）数据准备-3"><a href="#（0）数据准备-3" class="headerlink" title="（0）数据准备"></a>（0）数据准备</h6><pre><code>[atguigu@hadoop102 datas]$ touch sort.sh[atguigu@hadoop102 datas]$ vim sort.sh bb:40:5.4bd:20:4.2xz:50:2.3cls:10:3.5ss:30:1.6</code></pre><h6 id="（1）按照“：”分割后的第三列倒序排序。"><a href="#（1）按照“：”分割后的第三列倒序排序。" class="headerlink" title="（1）按照“：”分割后的第三列倒序排序。"></a>（1）按照“：”分割后的第三列倒序排序。</h6><pre><code>[atguigu@hadoop102 datas]$ sort -t : -nrk 3  sort.sh bb:40:5.4bd:20:4.2cls:10:3.5xz:50:2.3ss:30:1.6</code></pre><h3 id="第11章-企业真实面试题（重点）"><a href="#第11章-企业真实面试题（重点）" class="headerlink" title="第11章 企业真实面试题（重点）"></a>第11章 企业真实面试题（重点）</h3><h4 id="11-1-京东"><a href="#11-1-京东" class="headerlink" title="11.1 京东"></a>11.1 京东</h4><h5 id="问题1：使用Linux命令查询file1中空行所在的行号"><a href="#问题1：使用Linux命令查询file1中空行所在的行号" class="headerlink" title="问题1：使用Linux命令查询file1中空行所在的行号"></a>问题1：使用Linux命令查询file1中空行所在的行号</h5><p>答案：</p><pre><code>[atguigu@hadoop102 datas]$ awk &apos;/^$/{print NR}&apos; sed.txt 5</code></pre><p>问题2：有文件chengji.txt内容如下:</p><pre><code>张三 40李四 50王五 60</code></pre><p>使用Linux命令计算第二列的和并输出</p><pre><code>[atguigu@hadoop102 datas]$ cat chengji.txt | awk -F &quot; &quot; &apos;{sum+=$2} END{print sum}&apos;150</code></pre><h4 id="11-2-搜狐-amp-和讯网"><a href="#11-2-搜狐-amp-和讯网" class="headerlink" title="11.2 搜狐&amp;和讯网"></a>11.2 搜狐&amp;和讯网</h4><p>问题1：Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？</p><pre><code>#!/bin/bashif [ -f file.txt ]; then   echo &quot;文件存在!&quot;else   echo &quot;文件不存在!&quot;fi</code></pre><h4 id="11-3-新浪"><a href="#11-3-新浪" class="headerlink" title="11.3 新浪"></a>11.3 新浪</h4><p>问题1：用shell写一个脚本，对文本中无序的一列数字排序</p><pre><code>[root@CentOS6-2 ~]# cat test.txt98765432101[root@CentOS6-2 ~]# sort -n test.txt|awk &apos;{a+=$0;print $0}END{print &quot;SUM=&quot;a}&apos;12345678910SUM=55</code></pre><h4 id="11-3-金和网络"><a href="#11-3-金和网络" class="headerlink" title="11.3 金和网络"></a>11.3 金和网络</h4><p>问题1：请用shell脚本写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符”shen”的文件名称</p><pre><code>[atguigu@hadoop102 datas]$ grep -r &quot;shen&quot; /home | cut -d &quot;:&quot; -f 1/home/atguigu/datas/sed.txt/home/atguigu/datas/cut.txt</code></pre><blockquote><p>声明：笔记采用自传智播客网络，共同学习共同进步。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LINUX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口抽象类</title>
    <link href="/2019/05/14/%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/2019/05/14/%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>自我反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interface</tag>
      
      <tag>Abstract Class</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
